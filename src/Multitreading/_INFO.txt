=== Основные цели использования многопоточности: ===
    1. Производительность
    2. Concurrency

=== Проблемы многопоточности ===

    1. Data race - это проблема, которая может возникнуть, когда
    два и более потоков обращаются к одной и той же переменной
    и как минимум один поток её изменяет.

    2. Deadlock - ситуация, когда 2 или более потоков
    залочены навсегда, ожидуют друг друга и ничего не делают.

        Чтобы не возникало DeadLock-а при синхронизации по разнвм объектам,
        нужно синхронизироваться в одинаковом порядке.

    LiveLock - то же самое, только потоки проделывают бесполезную работу.

    Lock starvation - ситуаци, когда менее приоритетные потоки ждут долгое время
    или всё время для того, чтобы могли запуститься.

=== Варианты создания нового потока: ===

    1 вариант:
    // Создание
    class MyThread extends Thread{ public void run() { код }
    // Запуск
    new MyThread().start();

    2 вариант:
    // Создание
    class MyRunnableImpl implements Runnable{ public void run() { код }
    // Запуск
    new Thread(new MyRunnableImpl()).start();

    Из-за отсутствия в Java множественного наследования,
    чаще используется второй вариант.

    Чтобы запустить новый поток, нужно использовать метод start().
    Если вызвать метод run(), он просто выполнится в текущем потоке.

=== Ключевые слова: ===

volatile - используется для пометки переменной, как хранящейся
    только в основной памями "main memory".
    !!! Для синхронизации значения переменной между потоками ключевое
    слово volatile используется тогда, когда только один поток
    может изменять значение этой переменной, а остальные потоки
    могут его только читать.

synchronized - блокирует доступ к области кода другим потокам,
    пока с ним работает один поток.
    Синхронизация идёт по монитору на уровне объекта или класса.
    Если синхронизируем динамический метод, синхронизация идёт
    по объекту (synchronize(this)).
    Если синхронизируем статический метод, синхронизация идёт
    по классу (synchronize(MyClass.class)).

    Если надо синхронизировать сразу несколько методов, в классе создаём
    static final Object lock = new Object();
    и синхронизируем необходимый код так synchronized(lock).

    Контрукторы не нужно синхронизировать, они синхронизированны
    на уровне Java.

=== Монитор ===

    Монитор - это сущность/механизм, благодаря которому достигается
    корректная работа при синхронизации.
    В Java у каждого класса и объекта есть привязанный к нему монитор.

=== Методы Thread: ===

// Если не задавать имя, будет стандартное типа "Thread-0"
setName()
getName()

// Приоритет от 1 до 10, стандартный 5
// Можно задать числами или вариантами:
// MIN_PRIORITY (1), MAX_PRIORITY (10), NORM_PRIORITY (5)
setPriority()
getPriority()

sleep(t) - ожидание потока, "усыпление" на t миллисекунд.
join() - поток, В котором вызывается join(), ждёт окончания вызывающего потока.
    Может принимать верхний порог ожидания в миллисекундах.

interrupt() - сигнал о том, что мы хотим прервать поток.
isInterrupted() - возвращает true, если на потоке вызван interrupt().

=== Методы wait() и notify()

    Это методы для извещения других потоков о своих действиях.

    wait() - освобождает монитор и переводит вызывающий поток в состояние ожидания
    до тех пор, пока другой поток не вызовет метод notify().
    wait(t) - поток ждёт t миллисекунд.

    notify() - НЕ освобождает монитор и будит поток, у которого ранее
    был вызван метод notify().

    notifyAll() - НЕ освобождает монитор и будит ВСЕ потоки, у которых
    ранее был вызван метод wait().

=== Concurrency / Parallelism ====
=== Asynchronous / Synchronous ===

    Concurrency - соглассованность, означает выполнение сразу нескольких задач,
         но не обязательно в одно и то же время.
         Это как мак многозадачность на 1-ядерном процессоре.
    Parallelism - параллелизм, это concurrency, но с одновременным выполнением задач.

    Asynchronous - в асинхронном программировании можно не дожидаться выполнения одной
        задачи и во время её выполнения переключиться на другую.
        Это позволяет достичь concurrency.
    Synchronous - в синхронном программировании все задачи выполняются
        последовательно, одна за одной.

=== Lock и ReentrantLock ===

    Lock - интерфейс, который имплементируется классом ReentrantLock.
    Также, как ключевое словл synchronized, Lock нужен для достижения
    синхронизации между потоками.

    Методы Lock:

    lock() - блокирует код
    unlock() - разблокирует код
    tryLock() - если получается, блокирует, если нет,
        пропускает и выполняет код дальше. Возвращает boolean.

=== Daemon потоки ===

    Daemon потоки предназначены для выполнения фоновых задач
    и оказания различный сервисов User потокам.
    Если все User потоки завершены, программа завершится,
    не дожидаясь Daemon потоков.

    Методы:

    setDaemon(true) - делает из потока демон поток.
    Применять после создания и перед запуском потока.

    isDaemon() - является ли поток демоном.

=== Thread pool и ExecutorService ===

    Thread pool - это множество потоков, каждый из которых
    предназначен для выполнения той или иной задачи.

    В Java с Thread pool-ами уробнее всего работать
    посредством ExecutorService.

    Thread pool удобнее всего создавать, используя
    factory методы класса Executors:

        Executors.newFixedThreadPool(5) - создаст pool c 5 потоками;
        Executors.newSingleThreadExecutor() - создаст pool с одним потоком.


    execute() - передаёт наше задание (task) в Thread pool,
    где оно выполняется одним из потоков.

    submit() - для Callable. Возвращает объект Future.

    shutdown() - ExecutorService выполнит уже полученые задания и
    закончит работу (без этого программа не завершится).

    awaitTermination(5, TimeUnit.SECONDS) - принуждает поток, в котором
    он вызвался, подождать до тех пор, пока не выполнится одно из двух событий:
    либо ExecutorService прекратит свою работу, либо пройдёт время, указанное
    в параметре метода awaitTermination().

=== ScheduledExecutorService ===

    Используем тогда, когда хотим установить расписание
    на запуск потоков из пула.
    Данный пул создаётся, используя factory метод класса Executors:

    Executors.newScheduledThreadPool(int count).

    Методы:

    schedule() выполнит наши таски через определенный промежуток времени.
    scheduleAtFixedRate() планирует задачу для периодического выполнения
        с начала выполнения первой задачи до начала выполнения второй задачи.
        Если сразу после этого метода вызвать shutdown(), то она выполнится 1 раз.
    scheduleWithFixedDelay() фиксирует промежуток времени между
        завершением одной задачи и началом следующей.

=== Кешированный Thread pool ===

    Создаёт потоки по мере необходимости.
    Если 60 секунд поток не получает заданий, поток удаляется.

    ExecutorService executorService = Executors.newCachedThreadPool();

=== Интерфейс Callable ===

    Callable, так же, как и Runnable, представляет собой опрделённое задание,
    которое выполняется потоком. Используется только с ExecutorService-ами.

    В отличие от Runnable:
        - имеет возвращаемыё тип;
        - может выбрасывать Exception.

    Метод submit() передаёт наше задание (task) в thread pool
    для выполнения его одним из потоков и возвращает тип Future,
    в котором и хранится результат выполнения нашего задания.

=== Синхронизатор Semaphore ===

    Это синхронизатор, позволяющий ограничить доступ к какому-то ресурсу.
    В конструктор Semaphore нужно передавать количество потоков, которым
    он будет разрешать одновременно использовать этот ресурс.

    Методы:

    acquire()
    release()

=== Синхронизатор CountDownLatch ===

    