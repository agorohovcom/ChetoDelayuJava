====== JUnit 4 ======

@Test – определяет что метод method() является тестовым.

@Before – указывает на то, что метод будет выполняться перед каждым тестируемым методом @Test.

@After – указывает на то что метод будет выполняться после каждого тестируемого метода @Test

@BeforeClass – указывает на то, что метод будет выполняться в начале всех тестов,
а точней в момент запуска тестов(перед всеми тестами @Test).

@AfterClass – указывает на то, что метод будет выполняться после всех тестов.

@Ignore – говорит, что метод будет проигнорирован в момент проведения тестирования.
(expected = Exception.class) – указывает на то, что в данном тестовом методе
вы преднамеренно ожидаете Exception.
(timeout = 100) – указывает, что тестируемый метод не должен занимать больше чем 100 миллисекунд.

====== JUnit 5 =======

@BeforeEach
Аннотация @BeforeEach используется для обозначения того, что аннотированный метод
должен выполняться перед каждым методом @Test, @RepeatedTest, @ParameterizedTest
или @TestFactory в текущем классе.
Аннотация JUnit 5 @BeforeEach является одним из методов жизненного цикла
и заменяет аннотацию @Before в JUnit 4.
По умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeEach метод.

@AfterEach
Аннотация @AfterEach используется для обозначения того, что аннотированный метод должен
выполняться после каждого метода, помеченного @Test, @RepeatedTest, @ParameterizedTest
или @TestFactory в текущем классе.
Аннотация JUnit 5 @AfterEach является заменой аннотации @After в JUnit 4.
По умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @AfterEach метод.

@BeforeAll
Аннотация @BeforeAll используются для указания о том,
что аннотированный метод должен быть выполнен перед всеми
@Test, @RepeatedTest, @ParameterizedTest и @TestFactory методами в текущем классе.
По умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeAll метод.
Аннотированный @BeforeAll метод ДОЛЖЕН быть статическим методом в тестовом классе.
Или мы можем применить эту аннотацию к default методам интерфейса,
если тестовый интерфейс или тестовый класс аннотированы с помощью @TestInstance(Lifecycle.PER_CLASS).
Если этого не сделать, JUnit выдаст ошибку времени выполнения типа JUnitException.

@AfterAll
Аннотация JUnit 5 @AfterAll является заменой аннотации @AfterClass в JUnit 4.
Она используется как метод очистки для тестового класса.
@AfterAll используется для обозначения того, что аннотированный метод должен быть выполнен
после всех тестов в текущем тестовом классе.
Обратите внимание, что для выполнения метода после каждого теста мы можем использовать аннотацию @AfterEach.
Пожалуйста, помните, что:
Методы, аннотированные @AfterAll, должны иметь возвращаемый тип void, но не должны быть private.
Методы, аннотированные @AfterAll, могут опционально объявлять параметры,
которые должны быть разрешены ParameterResolvers.
Методы, аннотированные @AfterAll, наследуются от суперклассов, если они не скрыты или не  переопределены.
Кроме того,  @AfterAll методы из суперклассов будут выполняться перед  @AfterAll методами в подклассах.
Метод, аннотированный @AfterAll должен быть статическим,
в противном случае он будет выдавать ошибки во время выполнения.

@Test
Он используется, чтобы пометить метод как тест junit.

@RepeatedTest
Аннотация @RepeatedTest используется для написания повторяющихся тестовых шаблонов,
которые могут выполняться несколько раз в JUnit.
Частоту повторения можно настроить как параметр аннотации @RepeatedTest:
@RepeatedTest (5) - это означает, что тест будет выполнен пять раз.
Аннотация @RepeatedTest используется для обозначения метода тестирования,
который должен повторяться указанное количество раз с настраиваемым отображаемым именем.
Чтобы повторить тест с различными аргументами, рассмотрите возможность использования аннотации @ParameterizedTest.
Помимо указания количества повторений, мы можем дать каждому повторению собственное отображаемое имя.
Это настраиваемое отображаемое имя может быть комбинацией {статический текст + динамические заполнители}.
В настоящее время поддерживаются три заполнителя (placeholder):
{displayName}: отображаемое имя метода @RepeatedTest.
{currentRepetition}: текущее количество повторений.
{totalRepetitions}: общее количество повторов.
Мы можем использовать один из двух предопределенных форматов, то есть LONG_DISPLAY_NAME и SHORT_DISPLAY_NAME:
@RepeatedTest(value = 5, name = RepeatedTest.LONG_DISPLAY_NAME)
void method(TestInfo testInfo)
Последний формат используется по умолчанию, если он не указан.
RepeatedTest.LONG_DISPLAY_NAME – {displayName} :: повторение {currentRepetition} из {totalRepetitions}
RepeatedTest.SHORT_DISPLAY_NAME – повторение {currentRepetition} из {totalRepetitions}.
Интерфейс RepetitionInfo используется для получения информации
о текущем повторении повторяющегося теста внутри @RepeatedTest методов,
или методов жизненного цикла, таких как @BeforeEach, и @AfterEach.

@ParameterizedTest
Используйте аннотацию @ParameterizedTest, чтобы выполнить тест несколько раз, но с разными аргументами.
Нам не нужно использовать аннотацию @Test,
вместо этого в таких тестах используется только аннотация @ParameterizedTest.
Мы должны объявить по крайней мере один источник аргументов,
предоставляющий аргументы для каждого вызова, которые будут использоваться в тестовом методе.
Используйте аргумент name в аннотации @ParameterizedTest, чтобы настроить отображаемое сообщение.
Есть несколько способов передать аргументы методу тестирования:
1. Используйте @ValueSource для простых буквальных значений, таких как примитивы и строки.
   Она определяет один массив значений и может использоваться только для предоставления одного аргумента
   для каждого параметризованного вызова теста.
   Java поддерживает автобоксирование, поэтому мы также можем использовать литералы в их классах-оболочках.
   Мы не можем передавать null в качестве аргумента даже для типов String и Class.
   Пример: @ValueSource(ints = { 1, 2, 3 })
2. Аннотация @NullSource. Она предоставляет единственный null аргумент методу, аннотированному @ParameterizedTest.
3. Аннотация @EmptySource. Она предоставляет метод, аннотированный @ParameterizedTest,
   с единственным пустым аргументом следующих типов: java.lang.String, java.util.List, java.util.Set, java.util.Map,
   примитивные массивы (например, int []), массивы объектов (например, String []).
4. Аннотация @NullAndEmptySource. Она сочетает в себе функциональность @NullSource и @EmptySource.
5. Аннотация @EnumSource. Это удобный способ использования Enum констант.
   Метод тестирования будет вызываться для каждой константы перечисления за раз.
6. Аннотация @MethodSource.
   Она используется для ссылки на один или несколько фабричных методов тестового класса или внешних классов.
   Фабричный метод должен генерировать поток аргументов, где каждый аргумент в потоке будет использоваться методом,
   аннотированным @ParameterizedTest.
   Фабричный метод должен быть static, если тестовый класс не аннотирован с помощью @TestInstance(Lifecycle.PER_CLASS).
   Кроме того, фабричный метод не должен принимать аргументы.
   Пример: @MethodSource("argsProviderFactory")
   Если мы явно не предоставим имя фабричного метода через @MethodSource,
   JUnit будет искать фабричный метод, имя которого по умолчанию совпадает
   с именем текущего метода с аннотацией @ParameterizedTest.
   Поэтому, если мы не предоставим имя метода argsProviderFactory в аннотации @MethodSource,
   Junit будет искать имя метода testWithMethodSource с возвращаемым типом Stream<String>.
   Также поддерживаются потоки для примитивных типов (DoubleStream, IntStream и LongStream).
7. Аннотация @CsvSource. Эта аннотация позволяет нам задавать списки аргументов как значения, разделенные запятыми.
   Каждый CSV токен представляет собой строку CSV и приводит к одному вызову параметризованного теста.
   Задайте для свойства ignoreLeadingAndTrailingWhitespace значение true или false, указывающее на то,
   что Junit должен принимать или игнорировать пробелы в CSV токенах.
   Пример:
   @CsvSource(value = {
               "alex, 30",
               "brian, 35",
               "charles, 40"
           }, ignoreLeadingAndTrailingWhitespace = true)
8. Аннотация @CsvFileSource. Эта аннотация очень похожа на @CsvSource за исключением того,
   что мы читаем токены CSV из файла вместо чтения токенов в исходном тексте.
   CSV файл можно прочитать по classpath или из локальной файловой системы.
   Разделителем по умолчанию является запятая (,), но мы можем использовать другой символ, установив атрибут разделителя.
   Обратите внимание, что любая строка, начинающаяся с символа #, будет интерпретироваться как комментарий и игнорироваться.
9. Аннотация @ArgumentsSource. Аннотацию @ArgumentsSource можно использовать
   для указания настраиваемого многоразового поставщика аргументов ArgumentsProvider.
Чтобы написать тесты, которые могут использовать несколько аргументов, мы можем использовать следующие аннотации:
1. Аннотация @CsvSource. С помощью аннотации @CsvSource мы можем предоставить множество литералов и простых типов аргументов.
   Нам нужно предоставить все аргументы в одном токене CSV, а затем определить соответствующие аргументы метода.
   Пример:
   @CsvSource({
       "alex, 30, HR, Active",
       "brian, 35, Technology, Active",
       "charles, 40, Finance, Purged"
   })
2. Интерфейс ArgumentsProvider. Чтобы предоставить несколько тестовых аргументов сложных или настраиваемых типов,
   мы должны использовать аннотацию @ArgumentsSource с аннотацией ArgumentsProvider.
   В примере мы передаем три аргумента метода тестирования:
   testArgumentsSource, типов Employee, LocalDate и enum константы типа Direction.
   Пример:
   @ParameterizedTest
   @ArgumentsSource(EmployeesArgumentsProvider.class)
   void testArgumentsSource(Employee e, LocalDate date, Direction d) {
       assertTrue(Period.between(e.getDob(), LocalDate.now()).get(ChronoUnit.YEARS) > 40);
       assertNotNull(date);
       assertNotNull(d);
   }

@DisplayName
Используется для предоставления любого настраиваемого отображаемого имени для тестового класса или тестового метода

@Disable
Он используется для отключения или игнорирования тестового класса или тестового метода из набора тестов.

@Nested
Используется для создания вложенных тестовых классов

@Tag
Пометьте методы тестирования или классы тестов тегами для обнаружения и фильтрации тестов.

@TestFactory
Отметить метод - это тестовая фабрика для динамических тестов.